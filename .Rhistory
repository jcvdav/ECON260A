guess <- 0
X <- Xgrid[i]
#This finds optimal policy function
Thing = optim(par = guess,
fn = DynamicObjective260A,
gr = NULL,
lower = 0,
upper = X,
X = X,
a = a,
b = b,
delta = delta,
r = r,
K = K,
Xgrid = Xgrid,
V = Vmat[,t+1],
theta = theta,
method = "L-BFGS-B")
#the optimal Harvest for each stock
Hstar[i,t] <- Thing$par
Vmat[i,t] <- -Thing$value
}
xg <- data.frame(Xgrid)
hdf <- data.frame(Hstar)
vdf <- data.frame(Vmat[,1:T_fin])
II <- data.frame(index=1:XL)
hdf2 <- bind_cols(II,xg,hdf)
vdf2 <- bind_cols(II,xg,vdf)
hdf_new <- gather(data = hdf2,
key ="Xtime",
value = "harvest_opt",
num_range('X',1:T_fin)) %>%
mutate(T_end = T_fin + 1 - as.numeric(str_replace(Xtime, 'X', ''))) %>%
select(-Xtime)
vdf_new = gather(data = vdf2,
key = "Xtime",
value = "value_function",
num_range('X', 1:T_fin)) %>%
mutate(T_end = T_fin + 1 - as.numeric(str_replace(Xtime, 'X', ''))) %>%
select(-Xtime)
DF = left_join(hdf_new, vdf_new, by = c("index", "Xgrid", "T_end"))
DF_converge = DF %>%
filter(T_end == T_fin)
P1 <- ggplot(data = DF) +
geom_line(aes(
x = Xgrid,
y = harvest_opt,
color = T_end,
group = T_end
), size = 1) +
xlab("Stock, X") +
ylab("Opt. Harvest") +
scale_color_continuous(name = "Time to End")
P2 <- ggplot(data = DF, aes(x = Xgrid,
y = value_function,
color = T_end,
group = T_end)) +
geom_line(size = 1) +
xlab("Stock, X") +
ylab("Value Fn.") +
scale_color_continuous(name = "Time to End")
plot_grid(P1, P2, nrow = 2)
# Now do Forward Sweep
X0 <- 15 #Initial population size
#Initialize vectors
XX <- vector()
HH <- vector()
Pi <- vector()
Pipv <- vector()
#Starting stock for forward sweep
XX[1] <- X0
#Forward Simulation
simtime = seq(1, T_fin, length.out=T_fin)
nsims <- 10
results <- data.frame(sim = NA,
time = NA,
X = NA,
H = NA,
Profit = NA,
PVProfit = NA)
set.seed(42)
for (sim in 1:nsims){
for (tt in 1:T_fin){
HHtmp <- spline(Xgrid, Hstar[,tt] , xout = XX[tt] , method = "natural") #Interpolate to find harvest
HH[tt] <- HHtmp$y #Use interpolated harvest in period tt
z <- sample(x = c(1 + theta, 1 - theta), size = 1)
XX[tt+1] <- z * (XX[tt]-HH[tt]) + r*(XX[tt]-HH[tt])*(1-(XX[tt]-HH[tt])/K)
Pi[tt] <- a*HH[tt] - b*(HH[tt]^2)
Pipv[tt] <- (delta^tt)*Pi[tt]
}
sim_results <- data.frame(sim = sim,
time = simtime,
X = XX[1:T_fin],
H = HH[1:T_fin],
Profit = Pi[1:T_fin],
PVProfit = Pipv[1:T_fin])
results <- rbind(results, sim_results)
}
results %>%
select(sim, time, X, H) %>%
filter(!is.na(sim)) %>%
gather(variable, value, -c(time, sim)) %>%
arrange(sim, time, variable) %>%
ggplot(data = ., mapping = aes(x = time, y = value, color = variable)) +
geom_line(aes(group = sim)) +
geom_smooth(size = 2) +
startR::ggtheme_plot() +
scale_color_brewer(palette = "Set1") +
facet_wrap(~variable, scales = "free_y", ncol = 1)
theta <- 0.3
# Now do Forward Sweep
X0 <- 15 #Initial population size
theta <- 0.3
#Initialize vectors
XX <- vector()
HH <- vector()
Pi <- vector()
Pipv <- vector()
#Starting stock for forward sweep
XX[1] <- X0
#Forward Simulation
simtime = seq(1, T_fin, length.out=T_fin)
nsims <- 10
results <- data.frame(sim = NA,
time = NA,
X = NA,
H = NA,
Profit = NA,
PVProfit = NA)
set.seed(42)
for (sim in 1:nsims){
for (tt in 1:T_fin){
HHtmp <- spline(Xgrid, Hstar[,tt] , xout = XX[tt] , method = "natural") #Interpolate to find harvest
HH[tt] <- HHtmp$y #Use interpolated harvest in period tt
z <- sample(x = c(1 + theta, 1 - theta), size = 1)
XX[tt+1] <- z * (XX[tt]-HH[tt]) + r*(XX[tt]-HH[tt])*(1-(XX[tt]-HH[tt])/K)
Pi[tt] <- a*HH[tt] - b*(HH[tt]^2)
Pipv[tt] <- (delta^tt)*Pi[tt]
}
sim_results <- data.frame(sim = sim,
time = simtime,
X = XX[1:T_fin],
H = HH[1:T_fin],
Profit = Pi[1:T_fin],
PVProfit = Pipv[1:T_fin])
results <- rbind(results, sim_results)
}
results %>%
select(sim, time, X, H) %>%
filter(!is.na(sim)) %>%
gather(variable, value, -c(time, sim)) %>%
arrange(sim, time, variable) %>%
ggplot(data = ., mapping = aes(x = time, y = value, color = variable)) +
geom_line(aes(group = sim)) +
geom_smooth(size = 2) +
startR::ggtheme_plot() +
scale_color_brewer(palette = "Set1") +
facet_wrap(~variable, scales = "free_y", ncol = 1)
render_doc("Assig1.Rmd")
startR::render_doc("Assig1.Rmd")
knitr::opts_chunk$set(echo = FALSE,
message = FALSE,
warning = FALSE)
library(startR)
library(tidyverse)
startR::render_doc("Assig1.Rmd")
colnames(DF)
left_join(hdf_new, vdf_new, by = c("index", "Xgrid", "T_end")) %>%
filter(T_end == T_fin) %>%
gather(variable, value, -c(index, Xgrid, T_end)) %>%
ggplot(aes(x = Xgrid, y = harvest_opt, color = T_end, group = T_end)) +
geom_line() +
xlab("Stock, X") +
scale_color_continuous(name = "Time to End") +
facet_wrap(~variable, ncol = 1)
left_join(hdf_new, vdf_new, by = c("index", "Xgrid", "T_end")) %>%
filter(T_end == T_fin) %>%
gather(variable, value, -c(index, Xgrid, T_end)) %>%
ggplot(aes(x = Xgrid, y = value, color = T_end, group = T_end)) +
geom_line() +
xlab("Stock, X") +
scale_color_continuous(name = "Time to End") +
facet_wrap(~variable, ncol = 1)
left_join(hdf_new, vdf_new, by = c("index", "Xgrid", "T_end")) %>%
filter(T_end == T_fin) %>%
gather(variable, value, -c(index, Xgrid, T_end)) %>%
ggplot(aes(x = Xgrid, y = value, color = T_end, group = T_end)) +
geom_line() +
xlab("Stock, X") +
scale_color_continuous(name = "Time to End") +
facet_wrap(~variable, ncol = 1, scales = "free_y")
left_join(hdf_new, vdf_new, by = c("index", "Xgrid", "T_end")) %>%
filter(!T_end == T_fin) %>%
gather(variable, value, -c(index, Xgrid, T_end)) %>%
ggplot(aes(x = Xgrid, y = value, color = T_end, group = T_end)) +
geom_line() +
xlab("Stock, X") +
scale_color_continuous(name = "Time to End") +
facet_wrap(~variable, ncol = 1, scales = "free_y")
left_join(hdf_new, vdf_new, by = c("index", "Xgrid", "T_end")) %>%
filter(!T_end == T_fin) %>%
gather(variable, value, -c(index, Xgrid, T_end)) %>%
ggplot(aes(x = Xgrid, y = value, color = T_end, group = T_end)) +
geom_line(size = 1) +
xlab("Stock, X") +
scale_color_continuous(name = "Time to End") +
facet_wrap(~variable, ncol = 1, scales = "free_y")
left_join(hdf_new, vdf_new, by = c("index", "Xgrid", "T_end")) %>%
filter(!T_end == T_fin) %>%
gather(variable, value, -c(index, Xgrid, T_end)) %>%
ggplot(aes(x = Xgrid, y = value, color = T_end, group = T_end)) +
geom_line(size = 1) +
xlab("Stock, X") +
scale_color_continuous(name = "Time to End") +
facet_wrap(~variable, ncol = 1, scales = "free_y") +
ggtheme_plot()
render_doc("Assig1.Rmd")
# Now do Forward Sweep
X0 <- 15 #Initial population size
theta <- 0.3
#Initialize vectors
XX <- vector()
HH <- vector()
Pi <- vector()
Pipv <- vector()
#Starting stock for forward sweep
XX[1] <- X0
#Forward Simulation
simtime = seq(1, T_fin, length.out=T_fin)
nsims <- 50
results <- data.frame(sim = NA,
time = NA,
X = NA,
H = NA,
Profit = NA,
PVProfit = NA)
set.seed(42)
for (sim in 1:nsims){
for (tt in 1:T_fin){
HHtmp <- spline(Xgrid, Hstar[,tt] , xout = XX[tt] , method = "natural") #Interpolate to find harvest
HH[tt] <- HHtmp$y #Use interpolated harvest in period tt
z <- sample(x = c(1 + theta, 1 - theta), size = 1)
XX[tt+1] <- z * (XX[tt]-HH[tt]) + r*(XX[tt]-HH[tt])*(1-(XX[tt]-HH[tt])/K)
Pi[tt] <- a*HH[tt] - b*(HH[tt]^2)
Pipv[tt] <- (delta^tt)*Pi[tt]
}
sim_results <- data.frame(sim = sim,
time = simtime,
X = XX[1:T_fin],
H = HH[1:T_fin],
Profit = Pi[1:T_fin],
PVProfit = Pipv[1:T_fin])
results <- rbind(results, sim_results)
}
results %>%
select(sim, time, X, H) %>%
filter(!is.na(sim)) %>%
gather(variable, value, -c(time, sim)) %>%
arrange(sim, time, variable) %>%
ggplot(data = ., mapping = aes(x = time, y = value, color = variable)) +
geom_line(aes(group = sim)) +
geom_smooth(size = 2) +
startR::ggtheme_plot() +
scale_color_brewer(palette = "Set1") +
facet_wrap(~variable, scales = "free_y", ncol = 1)
library(tidyverse)
DynamicObjective260A <- function(H, X, a, b, delta, r, K, Xgrid, V, z = z) {
#To be used in optimization...this thing is minimized by choosing H
Pi <- a * H - b * (H ^ 2)
z <- sample(x = c(1 + theta, 1 - theta), size = 1)
# Xprime <- z*((X - H) + r * (X - H) * (1 - (X - H) / K))
Vnext <- spline(Xgrid, V, xout = Xprime, method = "natural")
negout<- -(Pi + delta * Vnext$y)
return(negout)
}
delta <- 0.9 #Discount factor
a <- 20 #alpha in payoff function
b <- 0.6 #beta in payoff function
r <- 0.3 #population growth rate
K <- 100 #population carrying capacity
theta <- 0 #stochastic part
T_fin <- 30
XL <- 100
#Grid over state space
Xgrid <- seq(from = 0.1,
to = K,
length.out = XL)
# Setting V = 0 at T_fin + 1
Vmat <-  matrix(data = 0,
nrow = XL,
ncol = T_fin + 1)
#Initialize the control vector
Hstar <- matrix(data = NA,
nrow = XL,
ncol = T_fin)
#Initialize the "new" value function
Vnew <- rep(NA, XL)
zs <- sample(seed = 42, x = c(1 + theta, 1 - theta), size = T_fin)
set.seed(42)
zs <- sample(x = c(1 + theta, 1 - theta), size = T_fin)
zs <- sample(x = c(1 + theta, 1 - theta), size = T_fin, replace = T)
for (t in seq(T_fin , 1 , -1)){
for (i in seq(1, XL, 1)){
guess <- 0
X <- Xgrid[i]
#This finds optimal policy function
Thing = optim(par = guess,
fn = DynamicObjective260A,
gr = NULL,
lower = 0,
upper = X,
X = X,
a = a,
b = b,
delta = delta,
r = r,
K = K,
Xgrid = Xgrid,
V = Vmat[,t+1],
z = zs[i]â™¦,
for (t in seq(T_fin , 1 , -1)){
for (i in seq(1, XL, 1)){
guess <- 0
X <- Xgrid[i]
#This finds optimal policy function
Thing = optim(par = guess,
fn = DynamicObjective260A,
gr = NULL,
lower = 0,
upper = X,
X = X,
a = a,
b = b,
delta = delta,
r = r,
K = K,
Xgrid = Xgrid,
V = Vmat[,t+1],
z = zs[i],
method = "L-BFGS-B")
#the optimal Harvest for each stock
Hstar[i,t] <- Thing$par
Vmat[i,t] <- -Thing$value
}
library(tidyverse)
DynamicObjective260A <- function(H, X, a, b, delta, r, K, Xgrid, V, z = z) {
#To be used in optimization...this thing is minimized by choosing H
Pi <- a * H - b * (H ^ 2)
z <- sample(x = c(1 + theta, 1 - theta), size = 1)
# Xprime <- z*((X - H) + r * (X - H) * (1 - (X - H) / K))
Vnext <- spline(Xgrid, V, xout = Xprime, method = "natural")
negout<- -(Pi + delta * Vnext$y)
return(negout)
}
delta <- 0.9 #Discount factor
a <- 20 #alpha in payoff function
b <- 0.6 #beta in payoff function
r <- 0.3 #population growth rate
K <- 100 #population carrying capacity
theta <- 0 #stochastic part
T_fin <- 30
XL <- 100
#Grid over state space
Xgrid <- seq(from = 0.1,
to = K,
length.out = XL)
# Setting V = 0 at T_fin + 1
Vmat <-  matrix(data = 0,
nrow = XL,
ncol = T_fin + 1)
#Initialize the control vector
Hstar <- matrix(data = NA,
nrow = XL,
ncol = T_fin)
#Initialize the "new" value function
Vnew <- rep(NA, XL)
set.seed(42)
zs <- sample(x = c(1 + theta, 1 - theta), size = T_fin, replace = T)
for (t in seq(T_fin , 1 , -1)){
for (i in seq(1, XL, 1)){
guess <- 0
X <- Xgrid[i]
#This finds optimal policy function
Thing = optim(par = guess,
fn = DynamicObjective260A,
gr = NULL,
lower = 0,
upper = X,
X = X,
a = a,
b = b,
delta = delta,
r = r,
K = K,
Xgrid = Xgrid,
V = Vmat[,t+1],
z = zs[i],
method = "L-BFGS-B")
#the optimal Harvest for each stock
Hstar[i,t] <- Thing$par
Vmat[i,t] <- -Thing$value
}
library(tidyverse)
DynamicObjective260A <- function(H, X, a, b, delta, r, K, Xgrid, V, z = z) {
#To be used in optimization...this thing is minimized by choosing H
Pi <- a * H - b * (H ^ 2)
z <- sample(x = c(1 + theta, 1 - theta), size = 1)
Xprime <- z*((X - H) + r * (X - H) * (1 - (X - H) / K))
Vnext <- spline(Xgrid, V, xout = Xprime, method = "natural")
negout<- -(Pi + delta * Vnext$y)
return(negout)
}
delta <- 0.9 #Discount factor
a <- 20 #alpha in payoff function
b <- 0.6 #beta in payoff function
r <- 0.3 #population growth rate
K <- 100 #population carrying capacity
theta <- 0 #stochastic part
T_fin <- 30
XL <- 100
#Grid over state space
Xgrid <- seq(from = 0.1,
to = K,
length.out = XL)
# Setting V = 0 at T_fin + 1
Vmat <-  matrix(data = 0,
nrow = XL,
ncol = T_fin + 1)
#Initialize the control vector
Hstar <- matrix(data = NA,
nrow = XL,
ncol = T_fin)
#Initialize the "new" value function
Vnew <- rep(NA, XL)
set.seed(42)
zs <- sample(x = c(1 + theta, 1 - theta), size = T_fin, replace = T)
for (t in seq(T_fin , 1 , -1)){
for (i in seq(1, XL, 1)){
guess <- 0
X <- Xgrid[i]
#This finds optimal policy function
Thing = optim(par = guess,
fn = DynamicObjective260A,
gr = NULL,
lower = 0,
upper = X,
X = X,
a = a,
b = b,
delta = delta,
r = r,
K = K,
Xgrid = Xgrid,
V = Vmat[,t+1],
z = zs[i],
method = "L-BFGS-B")
#the optimal Harvest for each stock
Hstar[i,t] <- Thing$par
Vmat[i,t] <- -Thing$value
}
xg <- data.frame(Xgrid)
hdf <- data.frame(Hstar)
vdf <- data.frame(Vmat[,1:T_fin])
II <- data.frame(index=1:XL)
hdf2 <- bind_cols(II,xg,hdf)
vdf2 <- bind_cols(II,xg,vdf)
hdf_new <- gather(data = hdf2,
key ="Xtime",
value = "harvest_opt",
num_range('X',1:T_fin)) %>%
mutate(T_end = T_fin + 1 - as.numeric(str_replace(Xtime, 'X', ''))) %>%
select(-Xtime)
vdf_new = gather(data = vdf2,
key = "Xtime",
value = "value_function",
num_range('X', 1:T_fin)) %>%
mutate(T_end = T_fin + 1 - as.numeric(str_replace(Xtime, 'X', ''))) %>%
select(-Xtime)
left_join(hdf_new, vdf_new, by = c("index", "Xgrid", "T_end")) %>%
filter(!T_end == T_fin) %>%
gather(variable, value, -c(index, Xgrid, T_end)) %>%
ggplot(aes(x = Xgrid, y = value, color = T_end, group = T_end)) +
geom_line(size = 1) +
xlab("Stock, X") +
scale_color_continuous(name = "Time to End") +
facet_wrap(~variable, ncol = 1, scales = "free_y") +
ggtheme_plot()
startR::render_doc("paper_proposal.Rmd")
here::here()
here::here("docs", "paper_proposal.pdf")
startR::render_doc("paper_proposal.Rmd")
knitr::knit()
knitr::knit
browseURL("file:///C:/Users/JC/Dropbox%20(Personal)/Escuela/4PhD/5Fall18/ECON260A/docs/paper_proposal.pdf")
?browseURL
browseURL("file:///C:/Users/JC/Dropbox%20(Personal)/Escuela/4PhD/5Fall18/ECON260A/docs/paper_proposal.pdf", browser = "")
Sys.getenv("R_PDFVIEWER")
browseURL("file:///C:/Users/JC/Dropbox%20(Personal)/Escuela/4PhD/5Fall18/ECON260A/docs/paper_proposal.pdf", browser = "C:\ProgramFiles\RStudio\bin\sumatra")
browseURL("file:///C:/Users/JC/Dropbox%20(Personal)/Escuela/4PhD/5Fall18/ECON260A/docs/paper_proposal.pdf", browser = "C:/ProgramFiles/RStudio/bin/sumatra")
browseURL("file:///C:/Users/JC/Dropbox%20(Personal)/Escuela/4PhD/5Fall18/ECON260A/docs/paper_proposal.pdf", browser = "C:/ProgramFiles/RStudio/bin/sumatra/SumatraPDF.exe")
browseURL("file:///C:/Users/JC/Dropbox%20(Personal)/Escuela/4PhD/5Fall18/ECON260A/docs/paper_proposal.pdf", browser = "C:/Program Files (x86)/Google/Chrome/Application/chrome.exe")
browseURL("file:///C:/Users/JC/Dropbox%20(Personal)/Escuela/4PhD/5Fall18/ECON260A/docs/paper_proposal.pdf", browser = "C:/ProgramFiles/RStudio/bin/sumatra/SumatraPDF.exe")
browseURL("file:///C:/Users/JC/Dropbox%20(Personal)/Escuela/4PhD/5Fall18/ECON260A/docs/paper_proposal.pdf", browser = "C:/Program Files/RStudio/bin/sumatra/SumatraPDF.exe")
browseURL("C:/Users/JC/Dropbox%20(Personal)/Escuela/4PhD/5Fall18/ECON260A/docs/paper_proposal.pdf", browser = "C:/Program Files/RStudio/bin/sumatra/SumatraPDF.exe")
tinytex::pdflatex
tinytex::latexmk
startR::render_doc("paper_proposal.Rmd")
browseURL("C:/Users/JC/Dropbox (Personal)/Escuela/4PhD/5Fall18/ECON260A/docs/paper_proposal.pdf", browser = "C:/Program Files/RStudio/bin/sumatra/SumatraPDF.exe")
browseURL("C:/Users/JC/Dropbox (Personal)/Escuela/4PhD/5Fall18/ECON260A/docs/paper_proposal.pdf", browser = "C:/Program Files (x86)/Google/Chrome/Application/chrome.exe")
browseURL("file:///C:/Users/JC/Dropbox (Personal)/Escuela/4PhD/5Fall18/ECON260A/docs/paper_proposal.pdf", browser = "C:/Program Files (x86)/Google/Chrome/Application/chrome.exe")
browseURL("file:///C:/Users/JC/Dropbox%20(Personal)/Escuela/4PhD/5Fall18/ECON260A/docs/paper_proposal.pdf", browser = "C:/Program Files (x86)/Google/Chrome/Application/chrome.exe")
startR::render_doc("paper_proposal.Rmd")
